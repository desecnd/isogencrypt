#pragma once

#include <arpa/inet.h>
#include <openssl/evp.h>
#include <openssl/sha.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "fp2.h"
#include "proto_msidh.h"

enum MSIDH_LEVEL {
    MSIDH_T100 = 0,
    MSIDH_T150,
    MSIDH_T200,
    MSIDH_NLEVELS,
};

static const struct msidh_const_data MSIDH_PARAMS[MSIDH_NLEVELS] = {
    {
        .t = 100,
        .a_str = "6",
        .xP_str = "676782264267647704374841078583377129084920411368462533161975"
                  "883862106168381374621964630435711031310199890121669098735728"
                  "601662060520619786791770866788191063158114472432232379973464"
                  "280756719439507936879154054541559903789696*i + "
                  "282112944123676408609495261586712812203713408247395183175137"
                  "461096334546904020125022139160812389963422190307194936726367"
                  "122106029835150671283058126220448180766790907504639045538223"
                  "643393944677488032699431588822694429908807",
        .xQ_str = "323673567822891057709541042541100780526373467728028962664795"
                  "951331955462362623648235524927611426085829813353179697678114"
                  "502960258799722693819650011493046737651891248384402804863118"
                  "25139786957074937789460893921127939478578*i + "
                  "790659894435988541838965364489716509500495044678106771763637"
                  "330713687360367120363885943452946719921091998096686199913863"
                  "567843743937032074428640648704582813280464335938644280877068"
                  "848855009972350768489454580631049447855480",
        .xR_str = "555681514866784111235320795562790330048828033500308950298140"
                  "884480073206729285147934444814579066077321513364911998778834"
                  "660073778528074528072850931277906825763407742457542084527734"
                  "140433441001321709155289976095024762678146*i + "
                  "699784705541245626746972809851120549881104679311434317817339"
                  "274196308856576144399491580834186237888201147647408270897063"
                  "702387883947094884736964822165723421108946083854470305412641"
                  "278697960284272294864849781531780078369445",
    },
    {
        .t = 150,
        .a_str = "6",
        .xP_str =
            "388751016565896480745408899101580940285103546781039113455871505855"
            "055823219587852425780688415959264687769029939057822787114598283528"
            "084010740070247687344939560276867537765453052032174102542941483261"
            "693756848990784403842341757566666551535213592020422599764004132971"
            "824029127049339745740988075096015001883924222026896986579902448488"
            "58480834839236586646737900814079*i + "
            "107153396793510161619651452752089550257388420764403939887802142485"
            "265972168464258683338821676946678212829727414336952653688233513853"
            "236529963063136943306372810613152597147607326829968525615995725087"
            "266666044875121111398689164969491845996362384179851063147840123976"
            "290690096867520820962968145047164616725223497475226679580560037878"
            "147912556227730093546152779110299",
        .xQ_str =
            "112269117766658518833498996477632954497157525964135019776205011274"
            "161646594839595755042054367951407616880190382239684532547765511411"
            "458849298061637321548652703682818238733478093606128836026111620800"
            "995105789392688317009570685013041740162900039152683905953907261695"
            "157159133359739450405779246676476931971591065173710130908366648331"
            "797537988861820880532386558525833*i + "
            "345604558668361144265626898791421943994138507158316307131420182125"
            "307273417015520907897379515554757451856392519115407330683615116522"
            "522139153374336509363744453468298207673532064356541224861426500971"
            "123929895959153165994190746834609210361536888362397999435204493638"
            "553203280402425034169079649623517155619849732268891433281252604964"
            "79613850850383305122763935142522",
        .xR_str =
            "994879383421764842656640696038809540176367569392159787996063069394"
            "987971395610430360502480685500639666763117515511830078212208249151"
            "608382701510208310324634584961199387084915025045317992288252154805"
            "297718909680466162953413173986498332199517517954600394729259493464"
            "360011120330292937737040097933295332565492531232687588674676692456"
            "51725146510431975875138857494723*i + "
            "426859777883693764796586480113862322523208583250052785936671111402"
            "040802296820970003958905687234104229518021156215101765185895167968"
            "693404208551054470956526622231484383901595537201050978691754392449"
            "889479934945912170909049066116728750775981878897257052636010702491"
            "894153075676943034748028142738286282142856016620178310480849546986"
            "47038566625545361916985972654317",
    },
    {
        .t = 200,
        .a_str = "6",
        .xP_str =
            "584377319988353226109140861313255722091016952488500106625886618186"
            "933839163966742553040635195459672349216727342788969092713867327748"
            "900684842362132848812558794195601402387782441839797319596035984438"
            "238387986553828241894881744308783274879802343254098842161948891956"
            "762586394319880244015867215223843528776666874488583665653730172169"
            "597772454044886426650115975573153359542674834589019909883399228683"
            "880509381775948270930031117314071559267429894374404924771726757854"
            "4111947507108591572754951560698883231009396150755455*i + "
            "867943604704408770151328411539419048048476093626516591039549431244"
            "957057727900923084255373715335413652817331708844894375516820026576"
            "664575275375137749009639749904832600825175984518485240328414379833"
            "664162133654429195386393222908066842598235087695074471326523070136"
            "256058676409034346119198511777814334832261314755525865938330836289"
            "802764988075612651298783784305469759107260396980484029124119902759"
            "706780238069850162678882427158119296177514608581981679529632917485"
            "904935607448792706043742782736728943403699647376053",
        .xQ_str =
            "106472459366347459919625330027174488199325904386548359611099443877"
            "119326682946826759085718961050346198601917531385406297916905676451"
            "166605302044227088614625963004058650407283154748656586986334566101"
            "331883117877017679128039672806777665396163722353723104054735807219"
            "722299650214813202339506375222346315018157942195513667949083417257"
            "173425335054598256198121739734167526928028378849836592161850514199"
            "537283095282349431096523627307622053442384693960843962599940705883"
            "4853091572839526663736294663086348485434839188739684*i + "
            "137426278349087604509805556801727870647806132548651518397229476647"
            "022852713905895128981713907946057172481260514644565462647019054286"
            "872593507822676652063432370198503591068003294752073779911526760169"
            "817877358843284028935726481453625201410170962700792988428396484724"
            "859177783510343160129076992603347692225887878791328162974505031836"
            "809794377110449871403910595841095710206775278443830618009742645540"
            "991182426900355412675706987612128858296480924733181256203604785681"
            "56926808214826195602643516273139766256047564379910681",
        .xR_str =
            "138830443524511537820157954243187714069352479231493929153135761807"
            "922089812323196309076019858740058383269418325260373510560040103241"
            "677956155851571903989879495937101916082620918728064216826867390565"
            "969986651292452891886564416566769133407338833273410478895311734777"
            "966897875213100792177387386211832096249893860324491741515152307306"
            "285819619933714913124295791787563549105034539052939893349175315503"
            "559390643467915351152664945623645276822849707817438721761866450026"
            "1479539704092522676765321354977199019161778241639132*i + "
            "170807059288858681117312602842725854212686377243203301153589603871"
            "587374058687428358474105214303473295433883597105748275967216616476"
            "185376444969829004163811803708964733727141359386822187572651624984"
            "682798337644934546873120818041265972539706176020031743601314057216"
            "362586802334082803969455109967556733572496166188484477538545134194"
            "336003175849629956896232272253427280815335940876366013869425653224"
            "833042190913677416435735527644729455978904858513997950344365027071"
            "38649853036202008097234357172361724972451034629668750",
    },
};

int send_u32(int fd, uint32_t val) {
    uint32_t val_be = htonl(val);
    // Send the u32 big-endian value to the other party
    if (write(fd, &val_be, sizeof(val_be)) != sizeof(val_be)) {
        return -1;
    }
    return 0;
}

int recv_u32(int fd, uint32_t *val) {
    uint32_t val_be;
    if (read(fd, &val_be, sizeof(val_be)) != sizeof(val_be)) {
        return -1;
    }
    *val = ntohl(val_be);
    return 0;
}

int send_fp2(int fd, fp2_t x) {
    size_t buff_size = fp2_write_size(x);
    char *buffer = malloc(buff_size);
    if (buffer == NULL) {
        return -1;
    }

    fp2_write(x, buffer);
    int ret = send_u32(fd, buff_size);

    // Something went wrong
    if (ret == -1) {
        free(buffer);
        return ret;
    }

    // Send fp2 stored as "b*i + a" decimal representation
    if (write(fd, buffer, buff_size) != (ssize_t)buff_size) {
        ret = -1;
    }

    free(buffer);
    return ret;
}

int recv_fp2(int fd, fp2_t x) {
    uint32_t buff_size;
    if (0 != recv_u32(fd, &buff_size)) {
        return -1;
    }

    char *buffer = malloc(buff_size);
    if (buffer == NULL) {
        return -1;
    }

    if (read(fd, buffer, buff_size) != buff_size) {
        free(buffer);
        return -1;
    }

    int ret = fp2_set_str(x, buffer);
    free(buffer);
    return ret;
}

int recv_msidh_data(int fd, struct msidh_data *md) {
    if (0 != recv_u32(fd, &md->t))
        return -1;
    if (0 != recv_fp2(fd, md->a))
        return -1;
    if (0 != recv_fp2(fd, md->xP))
        return -1;
    if (0 != recv_fp2(fd, md->xQ))
        return -1;
    if (0 != recv_fp2(fd, md->xR))
        return -1;
    return 0;
}

int send_msidh_data(int fd, struct msidh_data *md) {
    if (0 != send_u32(fd, md->t))
        return -1;
    if (0 != send_fp2(fd, md->a))
        return -1;
    if (0 != send_fp2(fd, md->xP))
        return -1;
    if (0 != send_fp2(fd, md->xQ))
        return -1;
    if (0 != send_fp2(fd, md->xR))
        return -1;
    return 0;
}

int msidh_handshake(int fd, int is_client,
                    unsigned char shared_key[SHA256_DIGEST_LENGTH],
                    enum MSIDH_LEVEL level) {
    if ((unsigned)level >= MSIDH_NLEVELS) {
        fprintf(stderr, "Invalid MSIDH level: %u, maximum allowed is: %u\n",
                level, MSIDH_NLEVELS);
        return -1;
    }

    // Public params
    struct msidh_data params, pk_self, pk_other;
    msidh_data_init(&params);
    msidh_data_init(&pk_self);
    msidh_data_init(&pk_other);

    // Parse the given MSIDH level
    const struct msidh_const_data *mcd = &MSIDH_PARAMS[level];
    params.t = mcd->t;
    fp2_set_str(params.a, mcd->a_str);
    fp2_set_str(params.xP, mcd->xP_str);
    fp2_set_str(params.xQ, mcd->xQ_str);
    fp2_set_str(params.xR, mcd->xR_str);

    // Alice: Send public key information
    struct msidh_state msidh;
    msidh_state_init(&msidh);

    msidh_state_prepare(&msidh, &params, is_client);
    msidh_get_pubkey(&msidh, &pk_self);
    int ret = 0;

    if (is_client) {
        ret = send_msidh_data(fd, &pk_self);
        if (ret == 0)
            ret = recv_msidh_data(fd, &pk_other);
    } else {
        ret = recv_msidh_data(fd, &pk_other);
        if (ret == 0)
            ret = send_msidh_data(fd, &pk_self);
    }

    // If there is a mismatch in parameters we need to abort the connection
    if (pk_self.t != pk_other.t) {
        ret = -1;
    }

    // Jump directly to exit to free the resources
    if (ret == -1) {
        goto exit;
    }

    msidh_key_exchange(&msidh, &pk_other);

    // Convert obtained j-invariant into SHA256 digest
    size_t buff_size = fp2_write_size(msidh.j_inv);
    char *buffer = malloc(buff_size);
    fp2_write(msidh.j_inv, buffer);
    SHA256((unsigned char *)buffer, buff_size, shared_key);
    free(buffer);

exit:
    // Clear all and return
    msidh_state_clear(&msidh);
    msidh_data_clear(&params);
    msidh_data_clear(&pk_self);
    msidh_data_clear(&pk_other);
    return ret;
}
